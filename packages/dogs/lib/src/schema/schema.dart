/*
 *    Copyright 2022, the DOGs authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

import "dart:convert";
import "dart:developer";

import "package:conduit_open_api/v3.dart";
import "package:dogs_core/dogs_core.dart";

/// Provides the ability to generate openapi schema objects for all registered structures.
class DogSchema {
  final Map<String, APISchemaObject> _cachedStructObjects = {};

  DogSchema._();

  /// Creates a new instance of [DogSchema].
  factory DogSchema.create() {
    final schema = DogSchema._();
    schema.retrieveComponents(); // Cache all current structure objects
    return schema;
  }

  /// Returns the schema object mapping for [structure].
  MapEntry<String, APISchemaObject> getStructureSchema(DogStructure structure) {
    final serialName = structure.serialName;
    if (_cachedStructObjects.containsKey(serialName)) {
      return MapEntry(serialName, _cachedStructObjects[serialName]!);
    }
    final properties = Map.fromEntries(structure.fields.map((e) {
      if (!e.structure) {
        APIType serialType;
        switch (e.serial.typeArgument) {
          case const (String):
            serialType = APIType.string;
            break;
          case const (int):
            serialType = APIType.integer;
            break;
          case const (double):
            serialType = APIType.number;
            break;
          case const (bool):
            serialType = APIType.boolean;
            break;
          default:
            throw Exception("Unhandled non structural serial serialType.");
        }
        final serialSchema = APISchemaObject.empty()..type = serialType;

        if (e.iterableKind == IterableKind.none) {
          final object = serialSchema;
          if (e.optional) object.isNullable = true;
          e.metadataOf<APISchemaObjectMetaVisitor>().forEach((element) {
            try {
              element.visit(object);
            } catch (ex, st) {
              log("Exception thrown at dog api schema generation",
                  error: ex, stackTrace: st);
            }
          });
          return MapEntry(e.name, serialSchema);
        } else {
          final object = APISchemaObject.array(ofSchema: serialSchema);
          if (e.optional) object.isNullable = true;
          e.metadataOf<APISchemaObjectMetaVisitor>().forEach((element) {
            try {
              element.visit(object);
            } catch (ex, st) {
              log("Exception thrown at dog api schema generation",
                  error: ex, stackTrace: st);
            }
          });
          return MapEntry(e.name, object);
        }
      }

      final APISchemaObject? object = e.findConverter(structure)?.output;
      if (object == null) {
        log("Can't find converter for ${e.name} in ${structure.serialName}");
        return MapEntry(e.name, APISchemaObject.empty());
      }

      if (e.optional) object.isNullable = true;
      e.metadataOf<APISchemaObjectMetaVisitor>().forEach((element) {
        try {
          element.visit(object);
        } catch (ex, st) {
          log("Exception thrown at dog api schema generation",
              error: ex, stackTrace: st);
        }
      });
      return MapEntry(e.name, object);
    }));
    final value = APISchemaObject.object(properties);
    structure.metadataOf<APISchemaObjectMetaVisitor>().forEach((element) {
      try {
        element.visit(value);
      } catch (ex, st) {
        log("Exception thrown at dog api schema generation",
            error: ex, stackTrace: st);
      }
    });
    _cachedStructObjects[serialName] = value;
    return MapEntry(serialName, value);
  }

  /// Returns the component part of the openapi document.
  APIComponents retrieveComponents() {
    final schemas = Map<String, APISchemaObject>.fromEntries(DogEngine
        .instance.allStructures.values
        .where((element) => !element.isSynthetic)
        .map((e) => getStructureSchema(e)));
    return APIComponents()..schemas = schemas;
  }

  /// Returns a mockup of the openapi document.
  APIDocument getApiDocument() {
    final document = APIDocument();
    document.version = "3.0.0";
    document.paths = {};
    document.info = APIInfo("DOG Mockup", "1.0",
        description:
            "Autogenerated component mockup of all registered structures which are not synthetic.");
    document.components = retrieveComponents();
    return document;
  }

  /// Returns the openapi mockup document as a json string.
  String getApiJson() => jsonEncode(getApiDocument().asMap());
}
