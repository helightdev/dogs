{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"Dart Object Graphs      <p>DOGs, short for Dart Object Graphs, is a universal serialization library making strong use of code generation to make your code more concise and fluent to write. The core package can be easily extended to support a wide array of encodings and comes with json support out of the box.</p> <p>Getting Started</p> <p>To get started with DOGs, you should start by reading Serializable Classes and continue on in the order of the sidebar. If you need help, you can always join our Discord.</p> <p>Getting Started!  Learn by Example! </p>"},{"location":"#important-links","title":"Important Links","text":"<p>GitHub  Discord </p>"},{"location":"annotation_catalog/","title":"Annotation Catalog","text":""},{"location":"annotation_catalog/#serialization-annotations","title":"Serialization Annotations","text":"<ul> <li> <p> Structure</p> <p>Generates a structure for the target. <code>serialName</code> can be specified to change the identifier used. <code>serializable: true</code> can be used to also make the structure serializable.</p> </li> <li> <p> Serializable / serializable</p> <p>Aliases for serializable <code>Structure</code>s. <code>serialName</code> can be specified to change the identifier used.</p> </li> <li> <p> EnumProperty</p> <p>The name of the enum constant can be overridden using the <code>name</code> parameter. Additionally, a single constant can be marked as <code>fallback</code> to handle invalid enum values.</p> </li> <li> <p> polymorphic</p> <p>Marks a field as polymorphic so that the actual runtime type is used for serialization.</p> </li> <li> <p> PropertySerializer</p> <p>Specifies the type of custom converter to be used for this fields' serialization.</p> </li> <li> <p> PropertyName</p> <p>Changes the name of the property used in serialization.</p> </li> <li> <p> DefaultValue</p> <p>Sets a default value for the field. If <code>keep</code> is <code>false</code>, the field will be omitted in serialization if it has the default value.</p> </li> <li> <p> excludeNull</p> <p>If applied to a member, direct null values will be excluded from serialization.</p> </li> <li> <p> LightweightMigration</p> <p>Applies a list of functions on deserialization to migrate data from older versions.</p> </li> <li> <p> RevisionMigration</p> <p>Applies migrations based on the revision number added to the map output.</p> </li> </ul>"},{"location":"annotation_catalog/#validation-annotations","title":"Validation Annotations","text":"<ul> <li> LengthRange</li> <li> Regex</li> <li> email</li> <li> <p> notBlank</p> </li> <li> <p> Range</p> </li> <li> Minimum</li> <li> Maximum</li> <li> positive</li> <li> positiveOrZero</li> <li> negative</li> <li> negativeOrZero</li> <li> SizeRange</li> <li> validated</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>To install the base package, modify your <code>pubspec.yaml</code> to include following packages:</p> pubspec.yaml<pre><code>dependencies:\n  dogs_core: any\n\ndev_dependencies:\n  build_runner: any\n  dogs_generator: any\n</code></pre> <p>The following additional packages are available for your convenience:</p> pubspec.yaml<pre><code>dependencies:\n  dogs_built: any # Support for built_value converters\n  dogs_yaml: any # Support for YAML files\n  dogs_toml: any # Support for TOML files\n  dogs_cbor: any # Support for CBOR files\n</code></pre> <p>Also replace the <code>any</code> values with the desired/latest version constraints.</p> <p>After adding the packages, run <code>pub get</code> to download the packages and <code>pub run build_runner build</code> to generate the <code>dogs.g.dart</code> reactor file.</p> <p>After this, you just need to load the dogs engine from your entrypoint of choice:</p> main.dart<pre><code>import 'package:dogs_core/dogs_core.dart';\nimport 'dogs.g.dart';\n\nvoid main() {\n  configureDogs(plugins: [\n    GeneratedModelsPlugin()\n  ]);\n  // [...]\n}\n</code></pre> <p>Use build_runner watch</p> <p>When working with the dogs engine, it is recommended to use <code>build_runner watch</code> to automatically generate the <code>dogs.g.dart</code> file and <code>*.conv.g.dart</code> files when you make changes to your models. Changing the model and forgetting to run <code>build_runner</code> will not always result in exceptions, but it will result in unexpected behaviour as the generated code will not match the current model.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<pre><code>import 'package:dogs_flutter/dogs_flutter.dart';\nimport 'package:flutter/material.dart';\nimport 'package:todos/dogs.g.dart';\n\nvoid main() {\n  configureDogs(plugins: [\n    GeneratedModelsPlugin(),\n    DogsFlutterPlugin(),\n  ]);\n  runApp(const MyApp());\n}\n</code></pre> <p>First, we always need to initialize the dogs engine so we can later use it. After installing the plugin, you can run the build_runner to generate the <code>dogs.g.dart</code> file, which contains the code for the initializer.</p> <pre><code>@serializable\nclass TodoEntry {\n  final String text;\n  final bool done;\n  final DateTime createdAt;\n\n  TodoEntry(this.text, this.done, this.createdAt);\n}\n</code></pre> <p>Next, we define our simple todo model using the <code>@serializable</code> annotation. After that, we run the build_runner again to generate the <code>*.conv.g.dart</code> files, which are automatically registered.</p> <pre><code>Checkbox(\n  value: entry.done,\n  onChanged: (value) {\n    setState(() {\n      todoEntries[i] = entry.copy(done: !entry.done);\n    });\n  },\n),\n</code></pre> <p>Now we implemented our simple todo view and create a checkbox that toggles the <code>done</code> state of the entry. To change the entry state, we use the <code>copy</code> method, which is automatically generated.</p> <pre><code>IconButton(\n  icon: const Icon(Icons.save),\n  onPressed: () {\n    final encodedText = dogs.toJson&lt;TodoEntry&gt;(entry);\n    showExportDialog(context, encodedText);\n  },\n),\n</code></pre> <p>We then add a button to share the entry as JSON. The <code>dogs.toJson</code> method is used to convert the entry to a JSON string, that is then display in a dialog.</p>"},{"location":"advanced/annotations/","title":"Annotations","text":"<p>Dogs make strong use of annotations to generate code for you and to add functionality to your classes and fields. Even though some annotations only work by using the code generator, many are also available for use without code generation at runtime.</p> <p>To achieve this extensibility without directly depending on the code generator, dogs retains all annotations implementing <code>StructureMetadata</code> in the structure definition. This is accomplished by reconstructing the constructor call of the annotation using the code_generator and the lyell companion library.</p>"},{"location":"advanced/annotations/#validation","title":"Validation","text":"<p>Validation is one of the features of dogs that makes heavy use of retained annotations. All annotation validators are created by making the annotation class extend <code>StructureMetadata</code> and implement <code>FieldValidator</code> or <code>ClassValidator</code>. When constructing the validation mode for the generated structure, the field annotations are collected and the individual validators are created.</p>"},{"location":"advanced/annotations/#converter-supplier","title":"Converter Supplier","text":"<p>Using the <code>ConverterSupplyingVisitor</code> interface, you can supply a converter for the annotated field.</p>"},{"location":"advanced/annotations/#code-examples","title":"Code Examples","text":"Getting a single field annotation<pre><code>DogStructureField field; /* Get field here*/\nfinal supplier = field.firstAnnotationOf&lt;ConverterSupplyingVisitor&gt;();\nif (supplier != null) {\n  return supplier.resolve(structure, field, engine);\n}\n</code></pre> Getting multiple class annotations<pre><code>DogStructure structure; /* Get structure here*/\nvar classValidators = structure.annotationsOf&lt;ClassValidator&gt;().toList();\n</code></pre>"},{"location":"advanced/hooks/","title":"Hooks","text":""},{"location":"advanced/hooks/#field-hooks","title":"Field Hooks","text":"<p>Field hooks enable fine-grained control over the serialization of individual fields. They are implemented by mixing in the <code>FieldSerializationHook</code> interface on a class that also implements <code>StructureMetadata</code>.</p> <p>Field hooks are executed for structure converters when using the <code>NativeSerializerMode</code>. They receive the field context and are able to modify the serialized map after a field has been serialized as well as before it is deserialized.</p> Field Serialization Hook Example<pre><code>class MultiplyByTwo extends StructureMetadata with FieldSerializationHook {\n  const MultiplyByTwo();\n\n  @override\n  void postFieldSerialization(\n      NativeStructureContext context,\n      NativeStructureFieldContext fieldContext,\n      Map&lt;String, dynamic&gt; map,\n      DogEngine engine) {\n    final value = map[fieldContext.key] as int?;\n    if (value != null) map[fieldContext.key] = value * 2;\n  }\n\n  @override\n  void beforeFieldDeserialization(\n      NativeStructureContext context,\n      NativeStructureFieldContext fieldContext,\n      Map&lt;String, dynamic&gt; map,\n      DogEngine engine) {\n    final value = map[fieldContext.key] as int?;\n    if (value != null) map[fieldContext.key] = value ~/ 2;\n  }\n}\n</code></pre> <p>The hook can then be applied to a field like any other annotation:</p> <pre><code>@serializable\nclass Example with Dataclass&lt;Example&gt; {\n\n  @MultiplyByTwo()\n  int number;\n\n  Example(this.number);\n}\n</code></pre>"},{"location":"advanced/hooks/#structure-hooks","title":"Structure Hooks","text":"<p>Structure hooks operate on the entire serialized map of a class. They are implemented by extending the <code>SerializationHook</code> class or implementing it. You can apply them to a structure by annotating the class with the annotation that extends <code>SerializationHook</code>.</p> <p>Structure hooks are executed for structure converters when using the <code>NativeSerializerMode</code>. They receive the full structure map and can freely modify it before deserialization or after serialization.</p> Structure Serialization Hook Example<pre><code>class ExampleHook extends SerializationHook {\n  const ExampleHook();\n\n  @override\n  void beforeDeserialization(\n      Map&lt;String, dynamic&gt; map,\n      DogStructure structure,\n      DogEngine engine) {\n    map['decoded_at'] ??= DateTime.now().toIso8601String();\n  }\n\n  @override\n  void postSerialization(\n      dynamic obj,\n      Map&lt;String, dynamic&gt; map,\n      DogStructure structure,\n      DogEngine engine) {\n    map['encoded_at'] ??= DateTime.now().toIso8601String();\n  }\n}\n</code></pre>"},{"location":"advanced/operation_modes/","title":"Operation Modes","text":"<p>Operation modes are a relatively unique concept to the dogs serialization library. They are used to provide different ways of consuming the auto-generated structure definitions.</p> <p>All converters must implement <code>resolveOperationMode</code>. This function is used to lookup converter specific operation modes, like the <code>NativeSerializerMode</code>.</p> <p>To make handling the operation modes more intuitive, the <code>OperationMapMixin&lt;T&gt;</code> is provided. It is used to provide a lookup table for operation modes. OperationMapMixin getter of the DateTimeConverter<pre><code>@override\nMap&lt;Type, OperationMode&lt;DateTime&gt; Function()&gt; get modes =&gt; {\n  NativeSerializerMode: () =&gt; NativeSerializerMode.create(\n    serializer: (value, engine) =&gt; value.toIso8601String(),\n    deserializer: (value, engine) =&gt; DateTime.parse(value)),\n};\n</code></pre></p>"},{"location":"advanced/operation_modes/#mode-registry","title":"Mode Registry","text":"<p>Operation modes are always resolved through the engine's <code>OperationModeRegistry</code>. This registry serves as a central cache and mapping from converters and types to operation mode entries. Child engines will always have their independent operation mode registry.</p> <p>Operation modes are always first looked up in the registry. For misses, the registry will first try to resolve the operation mode through the converter itself. If the converter does not provide the requested operation mode, the registry will try to infer the operation mode using the <code>OperationModeFactory</code>s registered in the current engine instance.</p>"},{"location":"advanced/operation_modes/#examples","title":"Examples","text":""},{"location":"advanced/operation_modes/#nativeserializermode","title":"NativeSerializerMode","text":"<p>The native operation mode is the most basic operation mode. It is used to serialize and deserialize objects to and from dart maps that can be directly serialized to JSON. Most of the dogs library is built around this operation mode.</p>"},{"location":"advanced/operation_modes/#validationmode","title":"ValidationMode","text":"<p>The validation operation mode is used to validate objects. It is used by the <code>@validate</code> annotation and can be used to validate objects before they are serialized, or to validate objects that have been deserialized.</p>"},{"location":"advanced/schema/","title":"Schemas","text":"<p>The library can generate schema definitions for all converters that support it and can also regenerate 'materialize' structures from those schema definitions. The schema definition format is JSON-based and a subset of JSON Schema with some custom framework-specific extensions, primarily used for styling in the Flutter integration.</p>"},{"location":"advanced/schema/#api-examples","title":"API Examples","text":"Export a Schema<pre><code>// This config fully expands all references for use in other tools \nfinal schemaConfig = SchemaConfig(useReferences: false);\n\nfinal schema = dogs.describe&lt;User&gt;(config: schemaConfig);\nfinal exported = schema.toJson();\n</code></pre> Define a schema using the dsl<pre><code>final schema = object({\n  \"name\": string(),\n  \"age\": integer().min(0),\n});\n</code></pre> Load a converter from a JSON schema<pre><code>final schema = parseSchema([...]);\nfinal converter = dogs.materialize(schema);\n// Use the proxy methods of the converter\n</code></pre> Import a json schema into the global dogs instance<pre><code>final schema = parseSchema([...]);\nfinal typeReference = dogs.importSchema(schema);\n// Use the returned type reference like a type tree\n</code></pre>"},{"location":"advanced/schema/#supported-json-schema-properties","title":"Supported JSON Schema Properties","text":"<ul> <li><code>type: string | number | integer | boolean | null</code></li> <li><code>enum: [string]</code></li> <li><code>default: any</code></li> </ul> <p>List/Array specific:</p> <ul> <li><code>minItems: int</code></li> <li><code>maxItems: int</code></li> <li><code>uniqueItems: bool</code></li> </ul> <p>Object specific: <code>required: [String]</code> (Only written, for reading only unions with <code>null</code> make fields optional)</p> <p>Number specific:</p> <ul> <li><code>minimum: number</code></li> <li><code>maximum: number</code></li> <li><code>exclusiveMinimum: number</code></li> <li><code>exclusiveMaximum: number</code></li> </ul> <p>String specific:</p> <ul> <li><code>minLength: int</code></li> <li><code>maxLength: int</code></li> <li><code>pattern: string</code></li> </ul>"},{"location":"advanced/structures/","title":"Structures","text":"<p>The code generator generates a <code>DogStructure</code> definition for every serializable class. These definitions are used by the <code>DefaultStructureConverter</code> to create the operation modes for the individual class.</p> <p>By default, they are generated by the dogs code generator for all serializable classes, but they can also be manually created and registered. This is useful when you want to write a custom converter for a foreign class. For simple type registrations without any structural information, you can use the synthetic <code>DogStructure</code> factory, to just create a structure for a given type together with a serial name.</p>"},{"location":"advanced/structures/#structure-properties","title":"Structure Properties","text":"<p>A generated or manually created <code>DogStructure</code> has following properties:</p> <ul> <li><code>serialName</code>: The name of the class when serialized. Primarily used for polymorphic serialization.</li> <li><code>type</code>: The type of the class, obtained via a <code>TypeCapture&lt;T&gt;</code>.</li> <li><code>annotations</code>: A list of retained annotations for this field.   Annotations are retained by the code generator and can be used to provide additional information   about the field or expand the functionality of the structure.</li> <li><code>proxy</code>: A proxy object for the class.   The proxy object is used to create instances of the class and to access the fields of the class.</li> <li><code>fields</code>: A list of <code>DogField</code> definitions for each field of the class.</li> </ul> Terminology: Retained Annotations <p>Retained Annotations are datastructures defined by the companion 'lyell' package, that are used to represent annotations at runtime. Retained annotations are, like the name suggests, retained by the code generator and can be accessed via the generated <code>DogStructure</code>.</p> <p>All classes which can be used as annotations can also be retained, if they are not private to the library they are defined in and implement the corrsesponding interface. For retained structure annotations, this means that they have to implement <code>StructureMetadata</code>.</p>"},{"location":"advanced/structures/#structure-proxies","title":"Structure Proxies","text":"<p>Structure proxies provide following functionality:</p> <ul> <li><code>instantiate</code>: Creates an instance of the structure with the given arguments.</li> <li><code>getField</code>: Gets the value of a single field of a given structure instance.</li> <li><code>getFieldValues</code>: Gets the values of all fields of a given structure instance.</li> </ul> <p>When using a dataclass conform structure, the proxy also defined following properties:</p> <ul> <li><code>hashFunc</code>: A function that calculates the hash of a given structure instance.</li> <li><code>equalsFunc</code>: A function that checks whether two structure instances are equal.</li> </ul>"},{"location":"advanced/structures/#field-serialization","title":"Field Serialization","text":"<p>How a field is serialized depends on the operation mode of the structure converter and the type of the field as well as the field properties. For all builtin serialization modes, the  <code>StructureHarbinger</code> decides the mapping of the field to a converter, which is then used to retrieve the operation mode for the field.</p> <p>Converter Resolution Priorities</p> <p>Annotation Supplied &gt; Converter Overrides &gt; Native Type &gt; Direct Converter &gt; Serial Converter &gt; Tree Converter.</p> Terminology: Direct Converter <p>A converter mapping is direct, if it can directy serialize a specific type without the need for iterable transformation or tree conversion. If a converter is associated to the type <code>List&lt;Person&gt;</code>, it can directly serialize this type and the harbing will not try to find a tree converter for <code>Person</code>.</p> Terminology: Serial Converter <p>Serial converters and tree converters are similar, in that they both serialize collection types. Though a tree converter is more powerful and can also be used for other types than dart native ones and with deeper nesting. Serial converters support only lists and sets of serializable types and are not able to serialize polymorphic types. Every dart converter is by default able to handle serial conversion through the \"{mode}Iterable\" methods on the respective operation modes. This behaviour can be turned off by using the <code>keepIterables</code> option on the converter.</p> <p>For graph and native operation modes, this includes the creation of a <code>TypeTree</code> based converter structure for each individual field. These individual tree converters are then used by the structure converter to serialize the whole class.</p>"},{"location":"advanced/structures/#type-tree-resolution","title":"Type Tree Resolution","text":"<p>The following flowchart shows the structure serialization process for a single field's type tree: <pre><code>graph LR\n  A[TypeTree] --&gt; B;\n  B{Is Terminal?} --&gt;|Yes| C;\n  C{Is Native?} --&gt; |Yes|D[Retain value];\n  C --&gt; |No| E;\n  E{Has associated DogConverter?} --&gt; |Yes| F;\n  E --&gt; |No| G[Polymorphic Serializer];\n  B --&gt; |No| H;\n  H{Has associated DogConverter?} ---&gt; |Yes| F[Use Converter];\n  H --&gt; |No| I;\n  I{Has associated TreeConverter?} --&gt; |Yes| J;\n  J[Use TreeConverter] ----&gt; |Potentially for type arguments| A;\n  I --&gt; |No| K[Throw Exception];</code></pre></p> Terminology: Type Trees <p>TypeTrees are datastructures defined by the companion 'lyell' package, that are used to represent arbitrary dart types. They are commonly generated by the dogs code generator and have following properties:</p> <ul> <li><code>base</code>: The base type of the represented type, represented by a <code>TypeCapture&lt;T&gt;</code></li> <li><code>typeArguments</code>: The type arguments of the represented type, represented by another <code>TypeTree&lt;T&gt;</code> </li> </ul> <p>additionally to to these properties, <code>QualifiedTypeTrees</code> also have the <code>TypeCapture&lt;T&gt;</code> property <code>qualified</code> representing the fully qualified type of this subtree which is used for type checks and casting. Dogs uses these qualified type trees to represent the field types. QualifiedTypeTrees are also necessary for TreeConverters.</p> <p>Is Load-Order Important? </p> <p>The structure converter is lazily loaded, meaning that it only generates the tree converter's operation mode when it is first used. This is done to prevent unnecessary load times and time-coupling in the initialization.</p> <p>This means that the order in which you define your serializable classes is not important.</p>"},{"location":"advanced/structures/#field-properties","title":"Field Properties","text":"<p>Additionally to the type of the field, the structure also stores following properties for each field:</p> <ul> <li><code>name</code>: The name of the field when serialized</li> <li><code>optional</code>: Whether the field is nullable or not</li> <li><code>structure</code>: Whether the field is a structure or not</li> <li><code>converterType?</code>: Defines a converter override for this field</li> <li><code>iterableKind</code>: Defines the kind of iterable this field is.     This can be <code>List</code>, <code>Set</code>, <code>Iterable</code> and <code>None</code>. Custom collection types can be handled     via tree converters but are not included in the structure definition and have to be derived     from the type tree.</li> <li><code>annotations</code>: A list of retained annotations for this field.     Annotations are retained by the code generator and can be used to provide additional information     about the field or expand the functionality of the structure.</li> </ul>"},{"location":"basics/converters/","title":"Custom Converters","text":"<p>Dog provides a number of built-in converters for common types. However, you may need to create your own converters for custom types. This section will explain how to create custom converters and how to register them in the <code>DogEngine</code>.</p>"},{"location":"basics/converters/#simple-converters","title":"Simple Converters","text":"Example using the SimpleDogConverter<pre><code>class LatLng {\n  final double lat;\n  final double lng;\n\n  LatLng(this.lat, this.lng);\n\n  @override\n  String toString() =&gt; \"LatLng($lat, $lng)\";\n}\n\n@dogsLinked/*(1)!*/\nclass LatLngConverter extends SimpleDogConverter&lt;LatLng&gt;/*(2)!*/ {\n  LatLngConverter() : super(serialName: \"LatLng\");\n\n  @override\n  LatLng deserialize(value, DogEngine engine) {\n    var list = value as List;\n    return LatLng(list[0], list[1]);\n  }\n\n  @override\n  serialize(LatLng value, DogEngine engine) {\n    return [value.lat, value.lng];\n  }\n}\n</code></pre> <ol> <li>The <code>@linkSerializer</code> annotation is used to automatically register compatible extensions in the <code>DogEngine</code>.</li> <li>The <code>SimpleDogConverter</code> class is a convenience class that implements <code>DogConverter</code> and provides    both the NativeSerializerMode and the GraphSerializerMode. It also creates a synthetic structure for    the converter type that uses the <code>serialName</code>.</li> </ol> <p>In this example, we created a converter for the <code>LatLng</code> class. The converter is registered in the <code>DogEngine</code> using the <code>@dogsLinked</code> annotation. The 'SimpleDogConverter' base class is the easiest way to create a converter \u2013 it implements the <code>DogConverter</code> interface and automatically creates a native serialization mode and a synthetic structure.</p> Manual Registration <p>To manually register a converter in the <code>DogEngine</code>, you can use the <code>registerAutomatic</code> method to register converter and also link both the structure and it's associated type.</p> <p>To only register the converter for a specific type, use <code>registerAssociatedConverter</code>. To only register a structure, use <code>registerStructure</code>. To only register a converter, without associating it with a type, use <code>registerShelvedConverter</code>.</p>"},{"location":"basics/converters/#tree-converters","title":"Tree Converters","text":"<p>Tree converters build a tree of converters based on a given <code>TypeTree</code>. In the newer versions of dogs, most of the complex serialization is done using tree converters.</p> <p>Each node inside the tree represents a single terminal or compound type. Generally, all type trees consist of a base type (e.g. <code>int</code>, <code>String</code>, <code>List</code>, <code>Map</code>, etc.) and a list of type arguments. There are also some special types of type trees for specific use-cases:</p> <ul> <li><code>QualifiedTypeTree</code> also contain a final combined type of the tree, which results in it being able to be fully   cached once constructed.</li> <li><code>SyntheticTypeCapture</code> doesn't define a base type, but uses the serial name of a structure like a type,   allowing dynamically generated structures to be used as if they had a backing type. To enable this, downstream   type safety is not guaranteed and trying to access the captured type will return <code>dynamic</code>.</li> <li><code>UnsafeRuntimeTypeCapture</code> uses the runtime type of value as a simple version of a type tree. Has the same   limitations as synthetic type captures.</li> </ul> <p>To construct a converter tree converter, the engine invokes the converter creation top-down, starting with the first base type. If the type tree has type arguments, the base converter will most likely resolve the type argument subtrees recursively.</p> <p>List Converter using createIterableFactory<pre><code>@dogsLinked\nfinal myListFactory = TreeBaseConverterFactory.createIterableFactory&lt;MyList&gt;(\n  wrap: &lt;T&gt;(Iterable&lt;T&gt; entries) =&gt; MyList(entries.toList()),\n  unwrap: &lt;T&gt;(MyList value) =&gt; value,\n);\n</code></pre> Iterable converters are the most basic and also the most common type of tree converters. They are easy to create and can be used to convert any type of iterable. The <code>wrap</code> and <code>unwrap</code> functions are used to convert the iterable to and from the tree's base type.</p> Manual Registration <p>You can register a custom tree base factory using the <code>registerTreeBaseFactory</code> method of the <code>DogEngine</code>.</p> Registering a custom tree base factory<pre><code>dogs.registerTreeBaseFactory(\n  TypeToken&lt;MyConverterBaseType&gt;(),\n  myCustomConverterFactory\n);\n</code></pre> Map Converter using NTreeArgConverter<pre><code>@dogsLinked\nfinal mapFactory = TreeBaseConverterFactory.createNargsFactory&lt;Map&gt;(\n  nargs: 2, consume: &lt;K, V&gt;() =&gt; MapNTreeArgConverter&lt;K, V&gt;()\n);\n\nclass MapNTreeArgConverter&lt;K,V&gt; extends NTreeArgConverter&lt;Map&gt; {\n  @override\n  Map deserialize(value, DogEngine engine) {\n    return (value as Map).map&lt;K,V&gt;((key, value) =&gt; MapEntry&lt;K,V&gt;(\n      deserializeArg(key, 0, engine),\n      deserializeArg(value, 1, engine),\n    ));\n  }\n\n  @override\n  serialize(Map value, DogEngine engine) {\n    return value.map((key, value) =&gt; MapEntry(\n      serializeArg(key, 0, engine),\n      serializeArg(value, 1, engine),\n    ));\n  }\n}\n</code></pre> <p>Don't use Type Constraints</p> <p>Since tree converters are dynamic in nature, they cannot statically enforce type constraints on their type arguments, as this would require down-casting type constraints at runtime, which is not possible in Dart.</p> <p>If type constraints are required, consider performing runtime checks inside the converter methods.</p> <p><code>NTreeArgConverters</code> are used to convert complex types that have a fixed number of type arguments. The consume method is used to expand the stored type arguments to usable generic type arguments which then need to be used to create a NTreeArgConverter. The <code>NTreeArgConverter</code> class provides the <code>deserializeArg</code> and <code>serializeArg</code> methods to convert generic items using the converter associated with the type argument at the given index.</p> Complex Container using NTreeArgConverter<pre><code>final containerFactory = TreeBaseConverterFactory.createNargsFactory&lt;Container&gt;(\n  nargs: 3, consume: &lt;A,B,C&gt;() =&gt; ContainerConverter&lt;A,B,C&gt;(),\n);\n\nclass Container&lt;A,B,C&gt; {\n  final A a;\n  final B b;\n  final C c;\n\n  Container(this.a, this.b, this.c);\n\n  String toString() =&gt; \"Container&lt;$A, $B, $C&gt;($a, $b, $c)\";\n}\n\nclass ContainerConverter&lt;A,B,C&gt; extends NTreeArgConverter&lt;Container&gt; {\n\n  @override\n  Container deserialize(value, DogEngine engine) {\n    return Container&lt;A,B,C&gt;(\n      deserializeArg(value[\"a\"], 0, engine),\n      deserializeArg(value[\"b\"], 1, engine),\n      deserializeArg(value[\"c\"], 2, engine),\n    );\n  }\n\n  @override\n  serialize(Container value, DogEngine engine) {\n    return {\n      \"a\": serializeArg(value.a, 0, engine),\n      \"b\": serializeArg(value.b, 1, engine),\n      \"c\": serializeArg(value.c, 2, engine)\n    };\n  }\n}\n</code></pre>"},{"location":"basics/options/","title":"Generator Options","text":"<p>The generator behavior can be configured using the <code>dogs</code> section in your <code>pubspec.yaml</code> file.</p> pubspec.yaml<pre><code>dev_dependencies:\n  build_runner: any\n  dogs_generator: any\n\ndogs:\n  library: false\n  property_case: keep\n  name_case: keep\n  enum_case: keep\n  nullable_accessors: false\n</code></pre>"},{"location":"basics/options/#options","title":"Options","text":""},{"location":"basics/options/#library-default-false","title":"<code>library</code> (default: <code>false</code>)","text":"<p>If set to <code>true</code>, the generator will generate library named modules instead to prevent conflicts when sharing models across multiple packages.</p>"},{"location":"basics/options/#property_case-default-keep","title":"<code>property_case</code> (default: <code>keep</code>)","text":"<p>Defines the casing style for generated property names.</p>"},{"location":"basics/options/#name_case-default-keep","title":"<code>name_case</code> (default: <code>keep</code>)","text":"<p>Defines the casing style for generated class and enum serial names.</p>"},{"location":"basics/options/#enum_case-default-keep","title":"<code>enum_case</code> (default: <code>keep</code>)","text":"<p>Defines the casing style for generated enum values.</p>"},{"location":"basics/options/#nullable_accessors-default-false","title":"<code>nullable_accessors</code> (default: <code>false</code>)","text":"<p>Forces builder accessor nullability regardless of the field nullability.</p>"},{"location":"basics/options/#casing-options","title":"Casing Options","text":"<ul> <li><code>keep</code>: Keep the original name.</li> <li><code>camel</code>: Convert to camelCase.</li> <li><code>pascal</code>: Convert to PascalCase.</li> <li><code>snake</code>: Convert to snake_case.</li> <li><code>kebab</code>: Convert to kebab-case.</li> <li><code>constant</code>: Convert to CONSTANT_CASE.</li> </ul>"},{"location":"basics/polymorphism/","title":"Polymorphism","text":"<p>DOGs supports polymorphism on a per-field basis. This means that you can have a field with any type you want, as long as all leaf types are serializable. If you want to use polymorphism, you need to add the <code>@polymorphic</code> annotation - This is required so you don't accidentally use polymorphism without knowing it.</p> Abstract classes and interfaces mustn't be annotated with @serializable <p>You only need to annotate concrete leaf classes with <code>@serializable</code>. Abstract classes and interfaces can't be instantiated and therefore can't use automatic structure generation, for which <code>@serializable</code> is the marker. (This excludes interop for built_value)</p> <p>Therefore: Only annotate concrete types with <code>@serializable</code>.</p> <p>You may specify custom converters for abstract classes and interfaces though, if you want to use them as explicit types. In this case, they will not be handled as polymorphic.</p> <p>Limitations</p> <p>All leaf types must be serializable. This means that you can use <code>dynamic</code> or <code>Object</code> as long as the actual runtime type is serializable i.E. the runtime type is associated with a structure definition and has a converter.</p>"},{"location":"basics/polymorphism/#discriminator","title":"Discriminator","text":"<p>To identity a leaf type in a polymorphic field, DOGs uses a <code>_type</code> discriminator, that is added to the serialized data of the object in question. If the leaf object is not a map, tha value will be wrapped in a map and stored in the <code>_value</code> field.</p>"},{"location":"basics/polymorphism/#when-do-i-need-to-use-polymorphic","title":"When do I need to use @polymorphic?","text":"<p>If all leaf node of your fields type tree are concrete classes, or have an associated structure and converter, you don't need to use <code>@polymorphic</code>.</p> Type Polymorphic? Explanation <code>int</code> <code>int</code> is a serializable class and therefore does not need to be annotated. <code>List&lt;int&gt;</code> <code>int</code> is a serializable class and therefore does not need to be annotated. <code>List&lt;Animal&gt;</code> <code>Animal</code> is an abstract class and therefore needs to be annotated. <code>List&lt;Object&gt;</code> <code>Object</code> is an abstract class and therefore needs to be annotated. <code>Map&lt;String,String&gt;</code> All leaf types are serializable classes therefore no annotation is required. <code>Map&lt;String,Animal&gt;</code> <code>Animal</code> is an abstract class and therefore needs to be annotated. <code>Map&lt;String,Object&gt;</code> <code>Object</code> is an abstract class and therefore needs to be annotated. <code>Map&lt;String,Person&gt;</code> <code>Person</code> is a serializable class and therefore does not need to be annotated. <code>Map&lt;String, List&lt;String&gt;&gt;</code> All leaf types are serializable classes therefore no annotation is required."},{"location":"basics/polymorphism/#examples","title":"Examples","text":"Sealed Classes<pre><code>sealed class Animal {}\n\n@serializable\nclass Dog extends Animal {\n  String name;\n  int age;\n\n  Dog(this.name, this.age);\n}\n\n@serializable\nclass Dolphin extends Animal {\n  bool isNamedFlipper;\n\n  Dolphin(this.isNamedFlipper);\n}\n\n@serializable\nclass Zoo {\n  @polymorphic\n  List&lt;Animal&gt; animals;\n\n  Zoo(this.animals);\n}\n</code></pre> Object Field<pre><code>@serializable\nclass Person {\n  String name;\n\n  @polymorphic\n  Object attachment;\n\n  Person(this.name, this.attachment);\n}\n</code></pre>"},{"location":"basics/projection/","title":"Projection","text":"<p>You can project multiple objects and maps into a single object by using the <code>Projection</code> class and its methods.</p> Data Transfer Objects (DTO) <p>When working with DTOs, you can use this method to create a new object from the data of the original object while also allowing you to merge in additional data from other serializable objects or maps.</p> Projection Expansion<pre><code>var user = Projection&lt;User&gt;()\n    .merge(NameAndAge(\"Alex\", 22))\n    .mergeMap({\"id\": \"1234\", \"isAdmin\": true})\n    .perform();\n</code></pre> Projection Reduction<pre><code>var reduced = Projection&lt;NameAndAge&gt;()\n    .merge(User(\"1234\", \"Alex\", 22, true))\n    .perform();\n</code></pre> <p>Projection operations are executed top-down in the order they were added.</p>"},{"location":"basics/projection/#reusable-projection-pipelines","title":"Reusable Projection Pipelines","text":"<p>Projection objects can be easily reused by using <code>unwrap</code> methods instead of <code>merge</code> methods. These methods will unwrap/'merge' value loaded from a specific path. The pipelines can then be invoked by specifying input values in the perform method.</p> Reusable Projection Pipeline<pre><code>final projection = Projection&lt;NameAndAge&gt;()\n  .unwrapType&lt;User&gt;(\"input\");\n\n// Usage\nfinal invoked = projection.perform({\n  \"input\": User(\"1234\", \"Alex\", 22, true)\n});\n</code></pre>"},{"location":"basics/serializables/","title":"Serializable Classes","text":"<p>To create a serializable class, just annotate it with <code>@serializable</code> and mixin <code>Dataclass&lt;T&gt;</code>. The code generator will then generate the required structure definition of your class.</p> <p>Explore Code Snippets</p> <p>You can explore the code in codeblocks by expanding comments using the floating (+) button.</p> <pre><code>@serializable /*(1)!*/\nclass Person with Dataclass&lt;Person&gt; /*(2)!*/ {\n\n  final String name;\n  final int age;\n  final Set&lt;String&gt;? tags; /*(3)!*/\n\n  Person(this.name, this.age, this.tags); /*(4)!*/\n\n}\n\n@serialzable // (5)!\nenum MyEnum { \n  a,b,c;\n}\n</code></pre> <ol> <li>The serializable annotation is required to make a class serializable.</li> <li>The dataclass mixin is optional but recommended, as it provides equals, hashCode and toString implementations.</li> <li>DOGs natively supports <code>List&lt;T&gt;</code> and <code>Set&lt;T&gt;</code> for any serializable type. While the field itself is allowed to be null, the elements of the iterable must not be null. If you require nested nullability, consider using the <code>Optional&lt;T&gt;</code> type.</li> <li>You constructor must only reference serializable field and must not be private. You can also use a secondary constructor for serialization by naming it <code>dogs</code>. Non-formal fields can also be used if they have a backing getter of field with the same name.</li> <li>You can also annotate enums to make them serializable. Enum values will be serialized and deserialized as strings using their name.</li> </ol>"},{"location":"basics/serializables/#conformities","title":"Conformities","text":"<p>Not every serializable class must be semantically equal to this dataclass example. Besides the initially presented dataclass, DOGs also supports the following other conformities:</p> BasicDataclassDataclass (named args)Beans <pre><code>@serializable\nclass Person {\n\n  String name;\n  int age;\n  Set&lt;String&gt;? tags;\n\n  Person(this.name, this.age, this.tags);\n}\n</code></pre> <p>If you don't use the dataclass mixin, the generator will not generate equality and hashcode implementations for this structure and you will have to implement them yourself if required. Since the generator doesn't expect this class to be immutable, you can use mutable fields and setters with this type of serializable class.</p> <pre><code>@serializable\nclass Person with Dataclass&lt;Person&gt; {\n\n  final String name;\n  final int age;\n  final Set&lt;String&gt;? tags;\n\n  Person(this.name, this.age, this.tags);\n}\n</code></pre> <p>Dataclasses are the most common type of serializable classes. They are immutable and their fields should be final. They are also the only type of serializable class you should use when you require equality.</p> <p>Named Argument Constructors</p> <p>You can also use named arguments with you dataclass constructor. This is especially useful when you have a lot of optional fields or many fields with the same type.</p> <pre><code>@serializable\nclass Person with Dataclass&lt;Person&gt; {\n\n  final String name;\n  final int age;\n  final Set&lt;String&gt;? tags;\n\n  Person({\n    required this.name,\n    required this.age,\n    this.tags\n  });\n}\n</code></pre> <p>Prefer other conformities like Dataclass!</p> <pre><code>@serializable\nclass Person {\n\n  late String name;\n  int? age;\n  Set&lt;String&gt;? tags;\n\n  @beanIgnore\n  late String ignored;\n\n}\n</code></pre> <p>Beans are the most flexible but also the most error prone type of serializable class. Serializable fields must be mutable and have a public no-arg constructor. They are only intended for frameworks which benefit from such a structure for simplicity.</p> <p>To instantiate a bean, you should use the generated <code>{name}Factory</code> class with its  static <code>create</code> method.</p>"},{"location":"basics/serializables/#field-variants","title":"Field Variants","text":"<p>To not limit your creativity, DOGs supports multiple ways to define serializable fields. This includes (super) formal parameters, which refer to fields and non-formal parameters which have a backing field or getter with the same name. This list showcases all possible variants:</p> Formal ParameterSuper Formal ParameterBacking FieldBacking Getter <pre><code>@serializable\nclass Entity with Dataclass&lt;Person&gt; {\n\n  final String id;\n  final String name;\n\n  Entity(this.id, this.name);\n}\n</code></pre> <pre><code>@serializable\nclass Entity extends Base with Dataclass&lt;Person&gt; {\n\n  final String name;\n\n  Entity({\n    required super.id,\n    required this.name\n  });\n}\n</code></pre> <p>The super field can have annotations</p> The super parameter must have a formal base definition <p>The super parameter must end up as a formal parameter in the superclasses constructor. Recursive backing fields or getters are not allowed in this case.</p> <pre><code>@serializable\nclass Entity with Dataclass&lt;Person&gt; {\n\n  final String id;\n\n  Entity(String? id) : this.id = id ?? Uuid().v4();\n}\n</code></pre> <p>Annotations go on the field</p> <p>Annotations for fields must be placed on the field itself, not on the constructor parameter.</p> <pre><code>@serializable\nclass Entity with Dataclass&lt;Person&gt; {\n\n  String? _id;\n\n  Entity(String? id) {\n    _id = id;\n  }\n\n  String get id =&gt; _id ??= Uuid().v4();\n}\n</code></pre> <p>Annotations go on the getter</p> <p>Annotations for fields must be placed on the getter itself, not on the constructor parameter.</p>"},{"location":"basics/serializables/#restrictions","title":"Restrictions","text":"<p>To make your serializable classes work with the serialization system, you must follow a few restrictions, some of them enforced by the code generator and some of them at runtime:</p> No Class-Level Generics <p>You cannot use generics on the class level. This is because the default structure generator generates a static structure definition for your class once, having dynamically changing field types would make this definition invalid. If you require generics for custom containers, you can implement a a tree base converter for this class.</p> Don't use Records <p>You cannot currently use records as field types, as the code generator does not support them. I plan on adding support for them sometime in the future though.</p> Types inside Field-Generics can't be nullable <p>You cannot use generic field types with nullable type arguments, as the type tree does not store the nullability of the type arguments. If you require nullable items, consider using the <code>Optional&lt;T&gt;</code> type instead, which is a wrapper for nullable types.</p> <p>In practice, this means that you can't use <code>List&lt;String?&gt;</code> but you can use <code>List&lt;Optional&lt;String&gt;&gt;</code>.</p> <p>However, the root type of the field can be nullable: <code>List&lt;String&gt;?</code> is perfectly fine without any changes.</p> All types must be serializable <p>All fields of your serializable class must be serializable recursively themselves. For sealed classes for example, this means that all possible subclasses must be serializable.  This also means, that they need to be marked as <code>@serializable</code> if they don't have a custom converter registered.  </p> <p>See Polymorphism for more information.</p> Parameters must either be formal or have a backing member with the same name <p>All parameters of your constructor must either be formal parameters (this./super.) or have a backing member with the same name. This class member can either be a field or a getter.</p>"},{"location":"basics/serializables/#modifications","title":"Modifications","text":"<p>You can use the automatically generated builder to modify serializable classes easily. Depending on your prefer code style, you can use either the imperative or lambda builder.</p> CopyLambda BuilderImperative Builder <pre><code>var updated = person.copy(\n  name: \"Alex\",\n  age: 22,\n);\n</code></pre> <p>This method is similar to Kotlin's <code>copy</code> and <code>copyWith</code>s which are common in dart libraries. Parameters which aren't explicitly overridden retain their original values, allowing you to even set fields to null.</p> <pre><code>var built = person.rebuild((builder) =&gt; builder\n  ..name = \"Alex\"\n  ..age = 22\n);\n</code></pre> <p>This method is similar to built's builder implementation.</p> <pre><code>var builder = person.toBuilder();\nbuilder.name = \"G\u00fcnter\";\nbuilder.age = 25;\nvar obj = builder.build();\n</code></pre> <p>Availability</p> <p>The builder is only available for dataclasses and basic serializable classes.</p>"},{"location":"basics/serializables/#special-annotations","title":"Special Annotations","text":"<p>Dogs include several annotations that can be used to modify the behavior of serialization and deserialization. Here is a (non-exhaustive) list of the most common annotations and their usage:</p> Annotation Applicable To Description <code>@PropertyName()</code> Field Sets the name of the field when serialized. This is useful if you want to use a different name for the field in the serialized data than in the class. <code>@EnumProperty()</code> Field The name of the enum constant can be overridden using the <code>name</code> parameter. Additionally, a single constant can be marked as <code>fallback</code> to handle invalid enum values. <code>@DefaultValue()</code> Field Sets a default value for the field. If the field is not present in the serialized data, the default value will be used. If the field is present, the default value will be ignored. If <code>keep</code> is set to <code>true</code>, the field will be included in the output even if it is equal to the default value. <code>@excludeNull</code> Field, Class Excludes the field from serialization if it is null. This is useful for fields that are optional and should not be serialized if they are not set. Can also be applied to a class to exclude all null values from serialization. <code>@LightweightMigration()</code> <code>@RevisionMigration()</code> Class Specifies migrations that can be applied before the data is deserialized."},{"location":"basics/serialization/","title":"Encoding and Decoding","text":"<p>You can use the global variable <code>dogs</code> to easily access any dogs related functionality. All default encoders, decoders and opmodes expose extension methods on the <code>DogEngine</code> class in the schema of <code>to{Format}&lt;T&gt;</code> and <code>to{Format}&lt;T&gt;</code>.</p> <p>Common Method Signature</p> <p><code>&lt;T&gt;</code> The return type parameter, which by default is used to lookup the converter. <code>kind:</code> Serialize lists and sets without specifying a type tree. <code>type:</code> Specify a type other than the return type parameter to be used for serialization. <code>tree:</code> Use a tree base converter resolution. Refer to  Tree Converters for more information.</p> <p>If the type is overridden by <code>type</code> or <code>tree</code>, the type parameter will only be  be used for casting.</p>"},{"location":"basics/serialization/#json-serialization","title":"JSON Serialization","text":""},{"location":"basics/serialization/#encoding","title":"Encoding","text":"SingleListMapRuntime TypeNullable Json Encode<pre><code>var person = Person(\"Alex\", 22, {\"developer\", \"dart\"});\nvar json = dogs.toJson&lt;Person&gt;(person);\n</code></pre> Encode List<pre><code>var persons = [Person(...), Person(...)];\nvar json = dogs.toJson(persons,\n    type: Person,\n    kind: IterableKind.list\n);\n</code></pre> Encode Map<pre><code>var personMap = {\"a\": Person(...)};\nvar json = dogs.toJson(personMap,\n    tree: QualifiedTypeTree.map&lt;String,Person&gt;()\n);\n</code></pre> <p>This is a general example for TypeTrees</p> <p>This can also be used for custom collections, wrappers, etc. For more information, refer to Tree Converters and Structures.</p> Json Encode Dynamic Type<pre><code>var person = Person(\"Alex\", 22, {\"developer\", \"dart\"});\nvar json = dogs.toJson(person,\n    type: PersonSupertype\n);\n</code></pre> Json Encode Nullable<pre><code>var json = dogs.toJson&lt;Person?&gt;(null,\n    type: Person,\n);\n</code></pre> <p>Syntax</p> <p>To support nullable types without Optional wrappers, you need to explicitly specify a nullable type parameter. Since most of the time no converter is bound to the nullable type, you also need to specify the type explicitly using the named 'type' parameter. You can also use a tree to resolve the type.</p>"},{"location":"basics/serialization/#decoding","title":"Decoding","text":"SingleListMapRuntime TypeNullable Json Decode<pre><code>var json = \"\"\"{\"name\":\"Alex\",\"age\":22,\"tags\":[\"developer\",\"dart\"]}\"\"\";\nvar person = dogs.fromJson&lt;Person&gt;(json);\n</code></pre> <p>Type Parameter required!</p> <p>Even when the type is inferred, you should always specify the type to avoid unexpected behavior.</p> Json Decode List<pre><code>var json = \"\"\"[{\"name\":\"Alex\",\"age\":22,\"tags\":[\"developer\",\"dart\"]}]\"\"\";\nvar persons = dogs.fromJson&lt;List&gt;(json,\n    type: Person,\n    kind: IterableKind.list\n).cast&lt;Person&gt;();\n</code></pre> <p>Type Parameter not required!</p> <p>In this case, the type parameter is not required, as type tree already dictates the type. It is just specified here so you don't have to cast the resulting type.</p> Json Decode Map<pre><code>var json = \"\"\"{\"a\":{\"name\":\"Alex\",\"age\":22,\"tags\":[\"developer\",\"dart\"]}}\"\"\";\nvar map = dogs.fromJson&lt;Map&lt;String,Person&gt;&gt;(json,\n    tree: QualifiedTypeTree.map&lt;String,Person&gt;()\n);\n</code></pre> <p>Type Parameter not required!</p> <p>In this case, the type parameter is not required, as type tree already dictates the type. It is just specified here so you don't have to cast the resulting type.</p> Json Decode Dynamic Type<pre><code>var json = \"\"\"{\"name\":\"Alex\",\"age\":22,\"tags\":[\"developer\",\"dart\"]}\"\"\";\nvar person = dogs.fromJson(json,\n    type: PersonSupertype\n);\n</code></pre> <p>Type Parameter not required!</p> <p>In this case, the type parameter is not required, as type tree already dictates the type. It is just specified here so you don't have to cast the resulting type.#</p> Json Decode Nullable<pre><code>var json = \"\"\"null\"\"\";\nvar person = dogs.fromJson&lt;Person?&gt;(json,\n    type: Person,\n);\n</code></pre>"},{"location":"basics/serialization/#native-serialization","title":"Native Serialization","text":"<p>You can also encode and decode objects from and to native dart objects. Values are considered native if they are serializable by the dart json encoder. All examples from the previous section can be used with native serialization as well by just changing the method name from <code>toJson</code> to <code>toNative</code> and <code>fromJson</code> to <code>fromNative</code>.</p> Native Encode<pre><code>var person = Person(\"Alex\", 22, {\"developer\", \"dart\"});\nvar json = dogs.toNative&lt;Person&gt;(person);\n</code></pre> Native Decode<pre><code>var encoded = {\n  \"name\": \"Alex\",\n  \"age\": 22,\n  \"tags\": {\"developer\",\"dart\"}\n};\nvar person = dogs.fromNative&lt;Person&gt;(encoded);\n</code></pre>"},{"location":"basics/validation/","title":"Validation","text":"<p>By default, all objects and structures are considered valid. You can change this behavior for all your serializable classes by using class and field validators. All validators have to be applied as annotations to their corresponding class or field.</p> <pre><code>@serializable\nclass User with Dataclass&lt;User&gt;{  \n\n  String name;\n\n  @positive/*(1)!*/\n  double age;\n\n  @SizeRange(min: 0, max: 16)/*(2)!*/\n  @Minimum(1)/*(3)!*/\n  List&lt;int&gt;?/*(4)!*/ claims;\n\n  @polymorphic/*(5)!*/\n  Object? attachment;\n\n  User(this.name, this.age, this.claims, this.attachment);\n}\n</code></pre> <ol> <li>The <code>@positive</code> annotation is a shorthand for <code>Range(min: 0, minExclusive: true)</code>.</li> <li>Requires the fields iterable to have a size between 0 and 16.</li> <li>Requires all elements of the iterable to be &gt;=1.</li> <li>Nullable fields are considered valid if they are null.</li> <li>The <code>@polymorphic</code> annotation is not a validator, but it is required for polymorphic    serialization.</li> </ol>"},{"location":"basics/validation/#built-in-validators","title":"Built-in Validators","text":"AnyStringsNumbersIterable <ul> <li><code>@validated</code> Requires the annotated field to also validate its properties. By default only the properties of the root object are validated.</li> </ul> <p>Validating Nested Objects</p> <p>Deep validation only works with non-tree based fields. Respectively, this works for all fields with direct converters and Lists, Sets and Iterables of those.</p> <p>Refer to Structures for more details on field serialization.</p> <ul> <li><code>@LengthRange()</code> Specify upper and lower bounds for the string length using the min and max properties.</li> <li><code>@Regex()</code> Specify a regex that the string will be matched against. The string is deemed invalid if it doesn't fully match the regex.</li> <li><code>@email</code> Requires a valid email address as per a reduced form of RFC 5322 where ip addresses, double quotes and square brackets are omitted.</li> <li><code>@notBlank</code> Requires a string that not only consists of whitespace.</li> </ul> <ul> <li><code>@Range()</code> Specify upper and lower bounds for the number using the min and max properties. The exclusiveness of the range can be specified by the corresponding properties.</li> <li><code>@Minimum()</code> Defines a lower bound for the number. The exclusiveness can be configured using minExclusive.</li> <li><code>@Maximum()</code> Defines a upper bound for the number. The exclusiveness can be configured using maxExclusive.</li> <li><code>@postive</code> Requires numbers to be greater than zero.</li> <li><code>@positiveOrZero</code> Requires numbers to be greater or equal to zero.</li> <li><code>@negative</code> Requires numbers to be smaller than zero.</li> <li><code>@negativeOrZero</code> Requires numbers to be smaller or equal to zero.</li> </ul> <ul> <li><code>@SizeRange()</code> Specify upper and lower bounds for the iterables length using the min and max properties.</li> </ul>"},{"location":"basics/validation/#runtime-validation","title":"Runtime Validation","text":"<p>Dataclasses can be easily validated at runtime using the <code>validate</code> method. This method will throw a <code>ValidationException</code> if the object is invalid. Otherwise, it will do nothing.</p> <p>If you want to validate an object without throwing an exception, you can use the <code>isValid</code> getter instead. It returns whether the object is valid or not.</p> Example (negative age)<pre><code>var user = User(\"Alex\", -999, [1, 2, 3], null);\nuser.validate(); // Throws ValidationException\nuser.isValid; // false\n</code></pre> <p>Validation Messages</p> <p>To perform validation with error messages, you can use the <code>validateAnnotated</code> method of the engine. This method will return a <code>AnnotationResult</code> instance that contains all messages.</p> <p>Continue Reading! </p>"},{"location":"built/","title":"Built","text":"<p>Dogs provide first-class support for integrating already existing or automatically generated built_value classes into the dogs engine.</p> <p>Getting Started! </p>"},{"location":"built/start/","title":"Getting Started","text":"<p>To get started, add the dogs_built package to your pubspec.yaml file:</p> <pre><code>dependencies:\n  dogs_built: any\n  built_value: any\n  built_collection: any\n</code></pre> <p>After this, the library import containing your built_value classes must be annotated with <code>@SerializableLibrary</code>. Exported libraries are automatically considered. To restrict which types get included, you can use the <code>include</code> and <code>exclude</code> parameters, which take a list of regular expressions. <pre><code>@SerializableLibrary(include: [\"package:petstore_api/src/model/.*\"])\nimport 'package:petstore_api/petstore_api.dart';\n</code></pre></p> <p>In your initialization code, you need to call <code>initialiseDogs</code> and <code>installBuiltSerializers</code> to register support for all built_value types as well as some internal converters exposed by built_value. <pre><code>import 'dogs.g.dart';\n\nFuture main() async {\n  await initialiseDogs();\n  installBuiltSerializers(PetstoreApi().serializers);\n}\n</code></pre></p> <p>Only one serializer can be installed at the same time</p>"},{"location":"firestore/","title":"Firestore","text":"<p>Only available on the Flutter platform</p> <p>Requires a Firebase project and account</p> <p>The dogs_firestore extension adds support for using the DOGs engine as an  ODM for Google's Cloud Firestore. The package also supports Firestore's native types, such as <code>Timestamp</code>, <code>GeoPoint</code> and <code>Blob</code>.</p> <p>Getting Started! </p>"},{"location":"firestore/mappings/","title":"Mappings","text":""},{"location":"firestore/mappings/#firestore-conversions","title":"Firestore Conversions","text":"<p>The firestore support package adds following conversions to make your life a bit easier:</p> Dart Type Firestore Type DateTime Timestamp Uint8List Blob <p>Those conversions override the default behaviour of the converter and are only applied when the converter is used in the firestore operation mode. This happens automatically when you use the the public api provided by the firestore support package and you don't have to worry about it.</p> <p>Normally, dogs already supports those types</p> <p>By default, dogs already has converters for <code>DateTime</code> and <code>Uint8List</code> that are used in the graph and native operation modes. Even though those could be used in the firestore operation mode as well, they are not used there, since the types they represent are supported by firestore natively.</p>"},{"location":"firestore/mappings/#interop-for-firestore-types","title":"Interop for Firestore Types","text":"<p>Of course, all firestore native types are also supported, though they only work in the firestore operation mode. To make them work outside of the firestore operation mode, you can use the <code>installFirebaseInterop</code> in your <code>main</code> method. This will install interop converts for all firestore native types, so that they can be used in the graph and native operation modes.</p> <p>Those interop converters perform following conversions:</p> Firestore Type Dart Native Type Format Timestamp String ISO8601 Blob String Base64 GeoPoint String \"$lat, $lon\" <p>Using those interop module allows you to perform json serialization on firestore native types</p> <p>This means, that you can send the data easily via http requests or store them in preferences.</p>"},{"location":"firestore/queries/","title":"Queries","text":"<p>Dogs offers a few static methods on the <code>FirestoreEntity</code> class to query the database. These methods are <code>get</code>, <code>find</code> and <code>query</code>. They are all asynchronous and return a <code>Future</code> of the requested entity/entities.</p>"},{"location":"firestore/queries/#get","title":"Get","text":"<p>The <code>get</code> method is used to retrieve a single entity from the database. It takes the id of the entity as an argument and returns a <code>Future</code> of the requested entity. You can additionally specify a <code>orCreate</code> argument, that takes a supplier function as an argument. If the entity is not found in the database, the supplier function will be called and the supplied entity will be stored in the database and returned.</p> Simple get<pre><code>var town = await FirestoreEntity.get&lt;Town&gt;(\"town_id_here\");\n</code></pre> Using the orCreate argument<pre><code>var town = await FirestoreEntity.get&lt;Town&gt;(\"town_id_here\",\n  orCreate: () =&gt; Town(\"London\", \"UK\"));\n);\n</code></pre>"},{"location":"firestore/queries/#find","title":"Find","text":"<p>The <code>find</code> method is used to retrieve a single entity from the database. It takes a <code>Query</code> as an optional argument and returns a <code>Future</code> of the requested entity. If no <code>Query</code> is specified, the first entity of the collection will be returned.</p> Simple find that returns the first entity<pre><code>var town = await FirestoreEntity.find&lt;Town&gt;();\n</code></pre> Find that returns the first entity that matches the query<pre><code>var town = await FirestoreEntity.find&lt;Town&gt;(\n    query: (q) =&gt; q.where(\"name\", isEqualTo: \"London\"),\n);\n</code></pre>"},{"location":"firestore/queries/#query","title":"Query","text":"<p>The <code>query</code> method is used to retrieve a list of entities from the database. It takes a <code>Query</code> as an optional argument and returns a <code>Future</code> of the requested entities. If no <code>Query</code> is specified, all entities of the collection are included in the query. To use pagination, you can specify a limit using the 'Query.limit' method. To set cursors, use the cursor methods on the <code>query</code> method itself, since they also take firestore entities as arguments.</p> Simple query that includes all entities<pre><code>var towns = await FirestoreEntity.query&lt;Town&gt;();\n</code></pre> Pagination with a cursor and a limit of 10<pre><code>var previous = // [...]\nvar towns = await FirestoreEntity.query&lt;Town&gt;(\n    query: (q) =&gt; q.limit(10),\n    startAfter: previous,\n)\n</code></pre> <p>To insert an entity into the database, use the <code>save</code> method of the entity itself</p> <pre><code>var person = Person(\"John\", 25);\nawait person.save();\n</code></pre>"},{"location":"firestore/start/","title":"Getting Started","text":"<p>To get started, add the dogs_firestore package to your pubspec.yaml file:</p> <pre><code>dependencies:\n  dogs_firestore: ^0.0.1\n</code></pre> <p>Then setup firebase by following the official documentation.</p> <p>After you have setup firebase, you can start using the package using either the extension methods or the <code>FirestoreEntity&lt;T&gt;</code> dataclass replacement.</p> Firestore EntityExtension Methods <pre><code>@serializable\nclass Person extends FirestoreEntity&lt;Person&gt; {\n  String name;\n  int age;\n  Timestamp? timestamp;\n  GeoPoint? location;\n\n  Person(this.name, this.age, this.timestamp, this.location);\n}\n\nvoid main() async {\n  await initialiseDogs();\n  installFirebaseInterop();\n  final person = Person('John', 42, Timestamp.now(), GeoPoint(0, 0));\n  await person.save();\n}\n</code></pre> <pre><code>@serializable\nclass Person with Dataclass&lt;Person&gt; {\n  String name;\n  int age;\n  Timestamp? timestamp;\n  GeoPoint? location;\n\n  Person(this.name, this.age, this.timestamp, this.location);\n}\n\nvoid main() async {\n  await initialiseDogs();\n  installFirebaseInterop();\n\n  final collection = FirebaseFirestore.instance\n    .collection(\"my_collection\")\n    .withStructure&lt;Person&gt;();\n\n  final person = Person('John', 42, Timestamp.now(), GeoPoint(0, 0));\n  await collection.add(person);\n}\n</code></pre>"},{"location":"firestore/subcollections/","title":"Subcollections","text":"<p>To specify subcollections, you can use the 'subcollectionOf' argument of the <code>@Collection</code> annotation. This will make the collection a subcollection of the specified entity and can only be accessed through the parent entity.</p> <pre><code>@serializable\nclass Town extends FirestoreEntity&lt;Town&gt; {\n\n  String name;\n  String country;\n\n  Town(this.name, this.country);\n\n}\n\n@serializable\n@Collection(subcollectionOf: Town)\nclass Person extends FirestoreEntity&lt;Person&gt; {\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n}\n</code></pre> <p>To insert a newly created entity into a subcollection, you can use the <code>store</code> method of the parent entity.</p> Inserting a subcollection entity<pre><code>var town = Town(\"London\", \"UK\");\nawait town.save();\nvar person = Person(\"John\", 25);\nawait town.$store(person);\n</code></pre> <p>All subcollection related methods are prefixed with a '$' sign</p> <p>They offer the same functionality as the static non-prefixed methods, but they are scoped to the parent entity. This currently includes: <code>$get</code>, <code>$find</code>, <code>$query</code>, <code>$store</code></p>"},{"location":"firestore/subcollections/#additional-examples","title":"Additional Examples","text":"Retrieving a subcollection entities<pre><code>var town = await FirestoreEntity.get&lt;Town&gt;(\"town_id_here\");\nvar persons = await town.$query&lt;Person&gt;();\n</code></pre> Retrieving a subcollection entity by id<pre><code>var town = await FirestoreEntity.get&lt;Town&gt;(\"town_id_here\");\nvar person = await town.$get&lt;Person&gt;(\"person_id\");\n</code></pre>"},{"location":"flutter/","title":"Flutter","text":"<p>This package provides Flutter specific functionality for the Dogs serialization library, including: </p> <ul> <li>Databinding and Form Generation</li> <li>Converters for Flutter specific types</li> </ul> <p>To install the base package, modify your <code>pubspec.yaml</code> to include following packages:</p> pubspec.yaml<pre><code>dependencies:\n  dogs_core: any\n  dogs_flutter: any\n\ndev_dependencies:\n  build_runner: any\n  dogs_generator: any\n</code></pre> <p>and replace the <code>any</code> with the desired/latest version constraint.</p>"},{"location":"flutter/binding/","title":"Data Binding","text":"<p>We provide a way to create a notifier-based controller for dog structures that can be used to simplify the process of building forms and data views using a dogs flavored workflow. Simple variants of the entire form or individual fields can be automatically generated using the structures and can be configured using metadata annotations. The controller fully supports the dogs_core validation system, allowing you to easily create form validations.</p>"},{"location":"flutter/binding/#state","title":"State","text":"<p>The entire state of a structure binding is stored in the <code>StructureBindingController</code> and can be initialized using a structure type with <code>StructureBindingController.create&lt;T&gt;()</code> or using a schema with <code>StructureBindingController.materialize(Schema)</code>.</p>"},{"location":"flutter/binding/#flutter-widget-binders","title":"Flutter Widget Binders","text":"<p>The <code>FlutterWidgetBinder</code> opmode is creates a <code>Widget</code> and <code>FieldBindingController</code> for a given field definition. The binder is usually inferred from the field type but can be manually overridden by specifying a supplying metadata annotation or by manually setting it using the <code>binder</code> property of the <code>FieldBinding</code> widget in flutter.</p>"},{"location":"flutter/binding/#field-binding","title":"Field Binding","text":"<p>A field binding widget automatically creates a <code>Widget</code> from the field definition and binds it to the <code>FieldBindingController</code> contained in the <code>StructureBindingController</code>. If the customizability of the field is not enough, you can always create a custom binder or just consume the state of the <code>FieldBindingController</code> directly in your widget tree.</p>"},{"location":"flutter/binding/#examples","title":"Examples","text":""},{"location":"flutter/converters/","title":"Converters","text":"<p>The dogs package for Flutter provides a set of sdk specific converters for commonly used Flutter types. Here is a comprehensive list of all converters provided by the package:</p> <ul> <li><code>Color</code> as a hex string in the format <code>#RRGGBB</code> or <code>#AARRGGBB</code></li> <li><code>Offset</code>, <code>Size</code>, <code>Rect</code>, <code>RRect</code>, <code>EdgeInsets</code>, <code>Radius</code>, <code>BorderRadius</code></li> <li><code>LogicalKeyboardKey</code>, <code>SingleActivator</code></li> </ul>"}]}